9月1号准备的面试题目：
1、SQL是什么？  结构化查询语言   与关系型数据库进行交流的语言。三大主流数据库有哪些？ mysql   orical   sql server 
2、当用户进行访问数据库的时候，他们是怎么进行交互的？ 用SQL语句

 2020年9月3号的面试题目：
 1、能在两种不兼容的数据类型之间进行数据转换吗？ 举个例子？ 不能 986INT转换成BIGINT还是986， int转换成datetime还是986吗？ 
 2、怎样去理解批处理？ 若干条命令进行同时整批处理，有些可以进行一批处理，
 3、如何理解使用SQL时用go。
 4、数据库我们一般常用的有哪些类型： 文本数据库、数值、（整数、小数（decimal/numeric、float、real））、null值（空）、日期类型（date、time、datetime）、真假（1/0）
 5、nvarchar和varchar有什么区别？ 使用Unicode编码 非Unicode编码


 2020年9月4号的面试题目：
 1、表内容中的增删查改中的增加的文本类数据如何避免一些错误？表名中列名与VALUE的值必须一一对应吗？ 文本数据是Unicode编码的：N'文本数据'  不一定 要看他的数据类型 顺序混乱可以，数据类型一一对应就可以了
 2、delete和truncate有什么区别？ 一个删除表里面的所有行，一个删除整个所有表包括表结构。
 3、在update的过程，有什么需要我们注意的？ 进行备份
 4、在SQL server中有哪些运算符？ 赋值运算、算术运算、文本运算、逻辑、比较运算、
 5、如何判断一个值是否为NULL值？

 2020年9月6号的面试题目：
 1、为什么需要约束？ 是为了数据的完整性，完整性：防止用户的出错 保证用户的输入符合我的输入数据类型  

 2020年9月7号的模拟面试题目：
 1、select一个别名,会更改数据本身吗？ 不会，知识相当于他的另外一个名字。
 2、是怎么理解orderby中出现两个不同的列的升序和降序问题的？ SELECT Id, Age, Score FROM Student ORDER BY Age ASC, Score DESC
 3、having和where的区别是什么?HAVING是在GROUP的结果中过滤，而WHERE是在GROUP之前就过滤
 4、select表复制复制那些属性? 属性类型、IDENTITY标记、NOT NULL约束等 但不能复制主外键关系
 5、哪些约束是可以暂时关闭约束检查？ check(自定义约束)和外键约束，关闭约束我们应该注意到什么？ 先关闭约束检查时，使用打开约束。

 2020年9月8号：
 1、什么是数据结构？ 如何组织、存储数据的逻辑形式
 2、什么是堆？ 是散乱无序的数据结构
 3、什么是聚集索引？ 聚集索引的叶子节点直接存放的就是行数据。和非聚集索引有什么区别？ 一个存放的是行数据，一个存放的是找到行数据的ID。
 4、全表扫描是什么？ 和iam 又是什么关系？ 如果一张表没有建立聚集索引，SQL SERVER会为每一张表建立一个索引分配映射（index allocation map），由iam依次记录着这张表所有页的信息，iam记录的是页里面存放数据的地址信息。 列如：p1-s1。
 当使用select语句进行查询时，SQL SERVER会以iam为基础，在iam记录的所有页上依次查找，直到查找出符合条件的数据，这就是全表扫描。 进行全表扫描的时候，会以iam为基础来进行查找。
 5、为什么需要非聚集索引？
 6、索引是干嘛用的？ 为了提高查询的速度和性能。是一个帮助我们快速查询的工具。SQL server会使用一列或多列的数据来构建一个索引列，当进行select查询的时候，可以先检查索引，通过索引找到索引列，能够取出完整的行数据了。
 7、当我们插入一行的时候，行数据究竟放置在哪里？ 是不是由这个数据的索引值决定的？  是怎么实现行数据位置存放的？ 页里面  
 8、什么是非聚集索引？非聚集索引的叶子节点中存放的不是实际行数据，而是存放行数据的ID，可以通过这个ID找到行数据。指针指向的是什么？如果Student表上已经在Id列建立了聚集索引，指针就记录这个Id（聚集索引的键值）即可；
如果Student表上还没有任何聚集索引，指针只能记录SQL Server为数据行建立的由文件Id、页Id和槽Id（FileID:PageId:SlotId）组成的RID（Row Id）。（也就是IAM里记录的RID？）
9、rid就是iam里面的数据存放的那一页那一个槽的位置？
10、为什么聚集索引比非聚集快?实际上当我们使用非聚集索引进行查找时，并不能直接的获取目标行数据。我们还得再根据其叶子节点中存储的“指针”，再在IAM或者聚集索引中进行查找，最终才能获得行数据。这就是“聚集索引比非聚集索引快”的原因

 2020年9月9号的面试题目：
1、建立索引应该注意哪些？ 确定索引的种类 聚集还是非聚集 非唯一还是唯一  命名规范 、索引建立在那个列上？
2、主键是唯一聚集索引吗？ 不一定 建立主键约束，如果表上没有建立聚集索引，sql SERVER 会自动创建一个聚集唯一索引  有聚集索引的话，就会自动建立一个非聚集唯一索引
3、执行计划的作用? 对查询进行优化
4、rid是什么？是iam里面所记录的数据的位置信息吗？  rid是由文件ID、页ID、槽ID 三者组成的 是
5、rid和iam分别是什么？ 他们之间有关联吗？ rid是由文件ID、页ID、槽ID 三者组成的 iam是由sqlserver自动生成的索引分配映射，iam记录的是表里面所有页的信息，依次记录的是数据存放的位置信息，rid就是iam里面的rid。
6、唯一约束和唯一索引有什么区别？ 唯一约束本质上是依赖唯一索引的。 唯一约束是在插入数据的时候对数据进行唯一检查，只能通过索引快速找到数据，删除唯一约束同时也会删除约束所依赖的索引

2020年9月10号的面试题目：
1、如果表上有聚集索引，sql server一定会进行聚集索引查找数据吗？ 为什么？
2、主外键一定是在两张表中产生的吗？ 不一定  比如 进行注册的时候，需要一个邀请人，被谁邀请就是一个外键列，外键列不一定是在主表上的。 
3、怎么样合理规划索引？ 

2020年9月13号的面试题目：
1、什么是数据的完整性？ 包含那三大完整性？ 分别是什么意思？ sql数据库要保证数据的完整性，sql server要保证数据正确且符合逻辑（通常使用约束来实现） 域完整性：限制每一列的数据 
实体完整性：要求某一列或多列上每一行的数据都是唯一的，每一行数据都有一个唯一标识符，以保证不能有完全相等的两行   参照完整性(主从表一致)：表与表（关联表）之间的数据是一致的，使用外键约束实现。
2、解释一下三大范式？ 第一范式：关系中每个属性都不可再分  第二范式：在第一范式的基础上，消除非主属性对码的函数依赖  第三范式：在第二范式的基础上，消除非主属性对码的传递函数依赖。
4、冗余的利弊：弊：会占磁盘空间，数据会出现重复，会破坏数据的一致性。
三大范式是消除不必要的重复，就称为：冗余  遵循三大范式的标准就会出现多张表联合查询，降低了查询性能，要去多张表上查询数据，
因为某些特定原因（通常是提高性能），宁愿从单表直接获取数据，也不愿多表联合查询，就是平常说的“以空间换时间”，
5、使用三大范式：是为了消除冗余，保证数据的一致性。 ，遵循的是多表联合查询，就可以使用第二范式。

2020年9月14号的面试题目
1、内连接和外连接有什么区别？  内连接，左表与右表有一行没有相对应的行数据，这一行数据就会被省略掉，不会出现在内连接表中  
外连接的话，左表与右表有一行没有相对应的行数据，如果左连接，那么右表这面会用null来补充，同理右连接也是一样的，不会丢失掉数据。

2020年9月18号：
1、使用表表达式的注意事项： 每一列都必须要列名，列名必须唯一，不保证排序，不能使用 order by
2、使用视图的作用是什么？1、通常是为了整理表间的复杂关系，为了给用户呈现清新、直观的数据。
3、介绍一下标准视图？数据库中存储的视图其实就是创建的select语句，看到的行和列都是来自于创建视图的基表。
4、视图选项的作用？绑定视图和基表之间的结构，被视图引用的列，都不能更改和删除。加密
5、索引视图？ 数据库中存储的视图是行数据
6、视图和表表达式的区别？ 视图创建时可以指定列名，是永久性的，除非显示的删除，可以基于多表联合的创建，表表达式：派生表查询结果只能使用一次，
CTE的子查询结果可以多次重复利用，还可以一次定义多个表，也是只能使用一次，声明一次，使用一次，一批处理完之后就不能再使用了

2020年9月20号：
1、局部临时表和全局临时表的区别？ 局部临时表：表名前有一个# ，只能在当前查询窗口可见   全局临时表： 表名前面有两个##，在所有会话都可见
2、解释一下异常和回滚 异常就是 sql语句本身是没有错误的，正常情况下能够顺利执行，产生的原因是无法预料到的外部结果。
3、有哪些排名函数？ROW NUMBER  RANK ORDER by后面跟有相等的值，会占有名次 DENSE NUMBER orderby 中两行值相等，相等值不会占有名次。
4、表变量是一定存储在内存中的吗？ 表变量是存放在tempdb中的，不一定，因为当内存足够的时候，存放表变量的页可以存放在缓存中。
5、你是怎么样认识tempdb的？ 是sqlserver自行维护的一个数据库，存储用户的临时表和表变量，还可以使用它完成许多系统工作，合理使用临时表可以提高系统性能。
6、事务：配合sqlserver的异常处理机制，确保：要执行全都执行，不执行全都不执行 异常如何处理： 先进行日志备份、也可以进行向系统管理员提交信息。

2020年9月21号：
1、事务的特征有哪些并解释一下？ acid： 原子性：事务作为一个整体都不可再分，要么就全都执行成功，要么全都不执行 隔离性：正在执行的事务不能被其他的事务所干扰。
一致性：事务的运行不能破坏数据的一致性 比如约束等  永久性：一旦改变就会是永久的
2、解释一下事务嵌套和save。在事务的基础之上在嵌套一个事务。save只是在事务中开启了一个保存点
3、什么是事务，配合哪些语句使用？并解释一下其意思？可以让某个数据经过修改之后，通过回滚使他恢复到原来的样子，要么全都执行成功，要么都不执行  begintry  +语句 commit
end try  begin catch rollback  end catch
4、事务的嵌套是怎么解决的？会回滚到最外层的事务，也就是最开始的事务， 可以设置一个事务点，只让他回滚到这个事务点上
5、事务隔离级别有哪些？ read  uncommit 可以避免脏读   read commit

2020年9月22号：
1、解释一下死锁是怎么造成的？
2、事务隔离级别有哪些？都是分别怎么解决对应的问题的？
3、解释一下u锁、s锁、x锁分别代表的意义是什么？
4、他们之间的兼容性是怎么样的？
5、事务隔离级别是锁之间是怎么实现的？ 是依靠粒度来实现的，粒度小，并发高，消耗资源，力度大，消耗资源少  降低并发度

2020年9月24号：
1、编程预言的特点有哪些？ 声明变量和赋值、分支、循环、函数 局部变量：是以@开头的，局部变量的作用域位于一个批处理语句当中 
全局变量：是以@@开头的，是不受批处理约束的，可以再任何地方使用，是由SqlServer自行定义的
2、有哪些系统函数？  聚合、数值、文本、日期、
3、文本函数可以分为哪些？
4、提高事务隔离级别能避免死锁的发生吗？
5、函数的作用是： 能够进行重用

2020年9月25号的面试题目：
1、函数可以分为哪些函数？ 他们的特点是什么？  函数可以分为：标量函数、单行表值函数、多行表值函数、系统函数（聚合、文本、日期、数值）
2、存储过程和函数有什么区别？ 1、函数能干的事存储过程都能做 2、函数必须要有返回值，不能对数据进行修改 3、能对数据进行修改
3、存储过程的优缺点有哪些？ 优点：1、事先编译，所以执行的更快 2、只需要向数据库传递存储过程名称和参数，花费流量更少。 缺点：1、可读性差、难以调试、不能在数据库之间进行迁移上
4、日期可以分为：dateadd增加、datediff计算时间差，n可以为负数、datepart 截取
5、T_SQL是一种强类型的语言，不兼容类型的数据之间不能进行运算，兼容类型的数据进行运算，先进行类型转换，可以用cast/convert来进行显示转换
6、触发器是什么？ 是一种特殊的存储过程
7、sql语言有哪四大类?dml 数据操作语言（对行数的增删查改，insert/update/delete/）ddl 数据定义语言(就是通常所用的drop、alter、create
传统上ddl不受事务的控制，truncate属于ddl,所以不能回滚)  tcl 事务控制语言 dcl 数据控制语言 
8、memcached  的命令格式是什么样的？ set  key  flags  exptime bytes noreply  存储 键值对 标注 内容 多少字节
9、memcached 的特点是什么？免费开源 分布式部署，通常是部署在Linux集群上  内存对象是数据库，数据存放在内存中，所以读写非常快  存储以键值对的形式存储

2020年10月6号的面试题目：
1、CRTL F5 和f5的区别？
3、debug和release的区别
5、什么是编译？ 把其他的高级语言或者自然语言编译成目标语言或者是二进制 什么是编码？把文本或者是字符，按照一种标准来进行转换，转成机器能读懂的机器码
6、强类型语言有什么特点：申明变量要指明数据类型，只能这种类型的数据才能符合要求，不能放其他类型的数据
7、什么是关键字？ 关键字是由系统保留，具有特定含义的字母，开发人员不能把它用作变量名。

2020年10月8号的面试题目：
1、什么是运算符优先级？ 一个表达式里有许多运算符，会按照一定的先后顺序来进行运算
2、逻辑运算与位运算的区别？逻辑运算是针对bool值进行逻辑运算的，位运算主要是针对二进制进行运算的，按位或和按位&可以应用于整数和bool值
3、短路运算？ 一旦得到结果，就不会进行后面的运算
4、比较运算： 是所有的数据类型都可以比较吗? 不是，比如：字符串和整数类型不能比较；要比较的话，用convert.TOINT32()，先进行转换，parse.int()

2020年10月9号的面试题目:
3、重构有什么作用？ 封装变化（可维护，方便维护），尽量减少外部的影响，在不改变原有代码运行结果的情况下，改变样式，对代码进行优化调整，解除耦合（删除代码之间的不可替代性，避免牵一发而动全身）
4、数组有什么特点？把变量看成是一个盒子，可以把数组想象成一排连续的盒子，里面放置数据（元素），这个数组的地址是连续的，声明一个数组的时候必须指定其类型，数组只能存放该类型的数据。
要得到里面的元素，就必须直到第一个盒子的地址，第n个元素，从第一个加n就能得到第n个元素的地址。
5、链表有什么特点？ 在堆里面寻找数据，像一个链条一样的绳子把散乱无序的数据连接起来，通过一个数据可以找到另一个数据
6、什么是数据结构? 什么是堆？ 是将数据如何存储、组织的逻辑形式 散乱无序的数据结构
7、数组有一维数组和多位数组、交错数组，交错数组的长度可以不一样

2020年10月11号的面试题目：
1、FOR循环和while循环之间有区别没有？ 该怎么选择呢？ 作用域：while循环是上一个花括号到下一个花括号结束。
for循环作用于当前的花括号的循环体。 for循环要紧凑一点，如果知道循环的次数，选择的是for循环，否则就选择while循环
2、do循环相比其他循环有什么特点？ do循环先把循环体执行一遍，然后在进行条件判断 while和for循环先条件判断之后，在执行循环体就
3、什么是迭代? 是指计算机反复执行的一段代码，和分支组合一起使用，是现代编程语言的流程核心
4、什么是遍历? 通过循环，依次获得数组中的每一个元素

2020年10月14号的面试题目：
1、break和return的区别？ break：会直接跳出循环体，而return会跳出函数。
2、复杂度可以分为哪些？可以举两个例子说明复杂吗？ 时间复杂度和空间复杂度： 时间复杂度也就是这个循环体循环的次数多少，空间复杂度也就是占用的空间的多少。
有一些算法的复杂度不同，可以分为三种：有指数级的，也就是复杂度比较高的（多重和嵌套循环），线性级，也就是复杂度一般的（单个循环），对数级复杂度相对较低（二分查找）
3、数据结构是算法的基础，算法是基于数据结构的 数据结构和算法之间有什么关系？
4、方法的调用是在哪里调用的？ 在哪里声明？ main方法里调用，program里声明
5、f11进入方法体内部和f10在方法体内部中设置断点有什么区别？ 从main方法直接转到声明的方法体，f10在内部设置断点，可以查看他的运行过程和结果。

2020年10月16号的面试题目：
1、out和ref的区别是什么? ref进行传入参数之前需要赋值，而out参数不用，ref是为了改变传入参数，out是为了获得。
2、C#默认的传递方式是什么？还有什么其他的传递方式？ 有什么特点？ 是值传递：传递的是变量的值，引用传递：传递的是变量本身，需要用ref和out来标记，
传入变量的值，调用的时候输出的还是原来的值，引用传递：输入的参数变量，就会进行一定的运算，列如：位置交换。
3、什么是重载？方法名是不能重复现的，但是在重载中，可以使用同一个方法名，配以不同的参数组合，来使用这些方法。  参数名不同，返回值不同
4、可选参数有什么特点？ 必须放置在必须参数后面，可选参数的默认值必须是编译时确定的，可选和不可选参数之间不能构成重载。调用的时候可以选择写或者不写
5、parameter在什么情况下使用？ 当参数是数组的时候，可以类型前面加个params,可以像向数组传递元素了。

2020年10月23号的面试题目：
1、引用类型和值类型有什么区别？值类型有什么好处？读取的速度快，
2、为什么需要构造函数？
3、为什么需要栈？ 是一种数据结构，因为函数的嵌套调用。
4、关键字this有什么作用？ 
5、readonly和constant有什么区别？  共同点：他们都是只读不进行更改， 不同点：readonly是只读，声明之后，可以延迟到construtor（构造函数）之后赋值，
constant常量一旦声明之后，就必须赋值，

2020年10月24号的面试题目：
1、类的字段都应该是私有的，都必须进行封装，属性是对字段的封装。属性本质上是方法。方法是对象的动作，属性是对象的状态。可以像使用字段一样使用属性，
如果要在属性中为取值添加逻辑，需要在get中添加代码  封装就是屏蔽内部实现，在set中实现。
2、什么是内存泄漏？新建立的对象没有释放，只是不断的去占有内存，没有进行回收，清除数据，以便下次使用。
3、get和set有什么区别？一个获取值，一个是去赋值  只有get没有set 这样属性就只读不能写，只有set没有get 这样属性就只写不能读
4、privateset 和set有什么区别没有？没有太大的区别，privateset 只能在自己的内部中设定，set能在外部设定
5、在自动属性中，我们能添加任何逻辑条件吗？不能，不能在get和set中添加任何逻辑，要添加，就要使用配合字段和属性
匿名类：其变量类型是var，所有属性只能是只读的，拥有相同属性的匿名类会被当做同一个类
索引器通常用于封装具有多个元素的数组，使用this
起构函数和构造函数有什么区别? 起构函数是在对象被销毁的时候调用，构造函数是在创建对象是被调用，无参，不需要显示声明，不需要在内部添加任何逻辑，起构函数是.net来进行自动调用的
强制回收的话,用gc.collect();

2020年10月26号的面试题目：
1、除了索引器，构造函数、字段、方法、属性即可以是实例的，也可以是静态的，静态构造函数不能被开发人员调用
，由.net运行在使用类之前,自动调用且仅一次，访问修饰符和参数对静态构造函数没有意义。给静态成员赋一个初始值。
2、静态类不能被实例化，其中只能有静态成员，不能有实例成员，但实例类中可以有静态成员，也就是实例类可以访问静态成员，静态成员不能访问实例类
静态成员是属于类的（公有），实例成员是属于每一个具体的对象的（独有）静态成员是属于类的，类不会被销毁，所以常驻内存的；一个类就是一个类，所以类的静态成员也是唯一的；
实例成员是属于对象的，而对象是new出来的，同一个类可以new出若干个对象，这些对象是各自独立的，所以他们的成员也是各自独立的。
3、能实例就不要静态，因为静态代表的是类，不是对象，
4、引入面向对象，是为了“分门别类”的归纳管理数量众多的方法，更重要的是，我们可以通过对象（而不是类），进一步的优化我们的代码。
5、静态方法：好的方法特点是：参数个数要少，实例方法的典型应用：尽可能用对象自有的数据来完成方法，而不是依赖于方法的参数传递。
一个对象的方法可以完全依赖于对象本身完成其功能，不带一个参数，这就是一种理想的面向对象的设计
6、面对实例和静态应该怎么选择？
7、说一说静态类和实例类的优缺点： 缺点：不能实例化，类是不会被销毁的，常驻内存，一个类就是一个类，类的静态成员也是唯一的  实例：
优点：实例：能面向对象，引入面向对象，是为了“分门别类”的归纳管理数量众多的方法，对象是new出来的，同一个类可以new出若干个对象
，可以通过对象，进一步优化我们的代码，静态：整理代码，实现代码的组织和重用，起到一定的封装作用。

2020年10月27号的面试题目：
1、实现继承的语法 ：子类继承父类，就可以使用父类的成员。继承发生在类与类之间，而不是对象之间，父类对象的任何数据都不会传递给子类，子类继承的是父类的模板
一个父类可以有多个子类，一个子类只能有一个父类。C#不支持多重继承。
2、静态类不能被继承，但实例类中的静态成员是可以被继承的
3、实例化一个子类，需要调用它所有的父类构造函数，因为要能够使用继承自父类的成员，必须调用一次父类的构造函数。
任何类都一样，要想使用这个类的成员，就必须先对这个类实例化一次，实例化就必须通过构造函数调用来实现。如果父类只有一个无参构造函数，.net运行时会默认调用这个无参构造函数
如果父类没有无参构造函数，那需要在子类的构造函数中指定具体调用父类的那一个构造函数。
4、子类可以访问父类的成员，父类有私有的成员，子类就不能访问 protected 还可以internal联合使用，当父类和子类不在同一个项目中使用
5、sealed;让某个类不能在被继承，父类装子类，实际上，这是一个父类变量引用指向一个子类对象，变量能够调用（。出来）什么，是由声明这个变量的类型决定的，而不是变量所引用的对象类型决定的
6、is有什么语法特点？类型判断是以运行时（即以所指向对象）为准，子类可以是自己、父类类型，父类对象不能是子类类型。
如果变量和类型之间没有继承关系，结果必然是false，变量为null（没有对象引用）也是false
7、讲一讲继承的滥用？ 继承的滥用是基于重用的逻辑，继承不是为了代码的重用，是为了多态，真正实现重用的，就是方法和组合（一个对象包含着若干个对象，或者若干对象组合成一个对象）

2020年10月29日的面试题目：
1、什么是多态？ 同一个变量，同一个方法，可以得到不同的结果。具体是怎么实现的？ 在父类中使用virtual关键字，在子类中使用override关键字，然后进行调用，就会得出不同的结果。
2、多态有什么语法特点？ 使用new关键字，就是子类和父类使用相同的方法时，在继承类中添加。父类装子类：使用的是谁的方法，看变量的类型。virtual：是在父类中添加，override是在子类中添加。
可以使用sealed，然后就不能被子类在override了。
3、多态的作用是什么？ 可以减少代码量，减少嵌套，可方便维护。让我们抽象的（面向对象的）设计实现成为可能。不考虑具体的实现细节，而是考虑对象的组织调用。面向对象的核心是代码的组织管理。
4、说一说你对抽象类的认识：由abstract修饰的类，抽象方法放置在抽象类中。抽象类不能实例化（还有静态的也不能被实例化），在抽象类里还可以声明其他的类成员，抽象方法是没有方法体的，
抽象类是可以有自己的方法，构造函数是为了给子类使用的。抽象方法所在的类，这个类的子类都要通过override来实现抽象类里面所有的方法，在override方法体内，不能通过base调用父类的抽象方法。
5、说说你对接口的认识：在接口内部只能声明方法和属性，不允许有字段和访问修饰符和方法体，也不能有其他的访问修饰符。接口一样不能被实例化，所以也不能有构造函数
接口也只可以继承接口，接口可以多重继承，子类要实现一个接口，就和抽象方法一样，必须实现接口的全部成员（接口继承的所有接口里面的成员）

1、为什么需要抽象类和接口？
2、结构有什么特点？结构和类相似的容器，结构能够实现接口，但不能继承其他结构和类，也不能被其他结构和类继承，默认有一个无参构造函数，不能显示声明，但有参构造函数可以显式声明
但构造函数必须保证结构中的多有字段和属性被赋值
3、结构的值类型有什么特点？结构类型是 值类型 。而值类型要求其所有成员必须有值！如果使用结构默认的无参构造函数，结构会自动的给所有成员赋默认值
4、值类型和引用类型该怎么选择？同样因为结构是值类型，值类型的优势是直接存放在栈中，可以快速读取；但它的数据量不能太大，否则就会耗用栈空间，反而拖累性能。
（引用类型的优势：只赋值地址不copy内容，传递时更快……）

2020年11月1日的面试题目：
1、什么是枚举？有什么特点？枚举是和class、struct并列的类型，包含两部分：名称和默认的底层数据类型是int,(不能是小数类型的，只能是整数类型)
（底层数据可以不写，默认是从0开始，依次增加1），它的成员又被称为枚举值，不能有访问修饰符。枚举的默认值是0所对应的枚举值，如果0找不到对应的枚举值，就直接为0.
2、枚举有什么作用？当参数是枚举值时，可以防止出错，可以提高代码的可读性和少BUG的出现。
3、switch...case有什么特点？只能进行等值运算，判断switch中的值是否等于case里面的值，用default来兜底，所有条件都不符合才执行default，
不要忘记break,break就跳出这个swicth作用域了，两个case之间没有break只有业务逻辑语句，就会报编译时错误。
4、什么是运算符重载？+只能进行述职类型之间的运算，当方法是public和static，有关键字operator，至少一个参数与返回值类型相匹配，任何一个类都可以进行运算符的重载，不是所有的运算符都可以重载
5、什么是转换类型重载？ 方法是public和static，有关键字operator 和implicit,显式的话，在值面前加上类型，就是一个显式转换
6、匿名类所用的类型是var

2020年11月2日的面试题目：
1、dynamic有什么特点？与var、object之间有什么区别？dynamic是动态类型，很多时候和Object是一致的，任何类型对象都可以用dynamic标记，
被标记的变量编译时不会报错（绕过编译时的类型检查），运行时会报错 var是推导类型，用于匿名类，变量一旦定义就不能更改其类型，
Object是C#中所有类型的父类，任何类默认自动的继承Object，不需要显示声明

2、怎么用枚举来做权限管理？默认的底层数据是int类型 特点是：2的n次方，或 |运算来添加权限，异或 ^运算来做删减权限，&与运算来判断用户有没有具体的某个权限。
3、说一说你对Object的看法，有什么认识？万物皆对象，值类型和引用类型都是继承自System.object的，
4、说一说Object常用的方法有哪些？ 有什么特点？equal是一个静态方法，用于两个参数作比较（参数传入的两个对象），
值类型，两个对象的值相同为true，反之为false，引用类型：有一个是null值 false，当两个变量指向同一个对象，true 反之false，
gethashcode:获取对象固定长度数据的算法 自己是virtual的，子类可以override，两个完全相同的对象GetHashCode()的Hash值必然相同，相同的Hash值并不意味着生成他们的对象相同
可以用GetHashCode()确定两个对象不相同，但不能用于确定他们相同。
gettype:获取当前对象的类型信息,当前对象 的类型信息,GetType()又被称之为获取变量的“运行时类型,经常与之相对比的是：typeof()，它获取的是类 的类型信息
因为传入typeof的就是一个类，所以可以在编译时就知道这个类的类型信息，它又被称之为获取类型的“编译时类型”。
tostring :将对象转换成字符串。注意这也是一个virtual方法，所以很多常用的.NET类库对象都重写了这个方法，比如DateTime。如果没有重写的话，默认返回对象的类的全名
所有类型被分为值类型（Value Type）和引用类型（Reference Type）
但都继承自Object
所有class定义的都是引用类型（数组继承自Array，是引用类型；String是一个行为特征非常类似于值类型的引用类型），其他struct/enum定义的都是值类型

4、装箱和拆箱有什么特点，怎么一回事？首先Object所引用的变量赋值，.net运行时自动生成Object的对象，将这个值自动的放到对象里面去，
与声明new一个对象的区别是：一个是系统自定义的对象，一个使用户定义的对象。如果有事另外的一个值，不是替换，是重新在内存上开辟一块新的对象空间来放值，这是装箱的过程，
拆箱：就是在要转换的Object变量前加对应的类型，装箱和拆箱只是用于值类型和Object之间，强制类型转换适用于任何有继承关系的类型 
装箱和拆箱多了一个创建Object的对象，而类型转换没有new生成一个对象的过程
5、object的equal和reference equal有什么区别？一个是进行值类型的比较，一个是进行引用类型：对象存储的地址的比较

2020年11月3日的面试题目：
1、反射有什么作用?来获取私有字段的值，用type和typeof来获取变量的类型信息，利用fieldinfo对象的get方法来获取值的，反射是.net程序运行时，可以动态获取并使用.NET程序集信息的技术。
.NET的反射只能应用于.NET程序，反射发生是在.NET程序运行时（不是编译时）C#写的源代码，会被编译后才执行；运行的时候都是二进制的机器码，看到的不是源代码，而是引用的.dll文件中的元数据
源代码编译成.dll文件的时候，它还同时生成了程序集的二进制描述性信息：元数据（metadata），并直接存放在.dll文件中。程序集的所定义和引用的有成员信息都包括在内，
包括程序集信息、类名、类成员和类的继承实现等等。反射就是依靠读取metadata实现其功能的。
metadata中没有方法的具体实现。换言之，metadata里记录了某个类中有某个方法，方法名、参数、返回值啥的它都知道，但它不知道这个方法具体是如何运行的。
记录方法如何运行的代码以MSIL（中间语言）的形式存放在.dll文件中 ILDASM： 反编译工具，我们可以将.dll（或者.exe）文件打开并进行阅读
一个程序集被反编译（不是反射）之后的内容，包括：Manifest（清单）：列明了该程序集的基本信息，
MSIL：微软中间语言格式的代码。这里被整理成了类（.class）、构造函数（.ctor）和方法（Main），双击Main方法
反射不能直接读取方法中的源代码，也不能读取经过编译过后的以MSIL格式的代码，唯一可以读取的是.dll文件中的方法对应的字节流（二进制文件内容）。反射就是利用这些字节流，来进行方法调用的。
反射主要应用于底层框架，在面向终端用户的应用程序（比如http://ASP.NET）开发中使用得非常少
2、特性：Flags被称之为特性。在 目标元素 上添加特性，这里我们称其为：特性的使用
特性可以被使用于任何目标元素，包括：类、类成员、enum、delegate、assembly
一个目标元素可以被附着多个Attribute
可以像方法一样加圆括号，里面接受构造函数参数、给属性赋值等 Flags本质上是一个继承了Attribute的类 定义一个特性类的行为，这里我们称其为：特性的声明
AttributeTargets.Enum 指定FlagsAttribute只能使用在枚举（Enum）上
Inherited=false 说明该特性无法被子类继承
可以标记某个类或者类成员（以下简称“元素”）已经过时 Obsolete
3、单元测试是开发人员自己用代码实现的测试 
SetUp：被标记的方法将会在每一个测试方法被调用前调用
Test：被标记的方法会被依次调用
tdd其全称是Test-Driven Development（测试驱动开发），其核心是：在开发功能代码之前，先编写单元测试用例代码
为其编写单元测试。确定方法应该实现的功能
测试，无法通过,因为没有方法实现嘛。但这一步必不可少，以免单元测试的代码有误，无论是否正确实现方法功能测试都可以通过
实现开发代码。比如在方法中完成方法体。调试是为了实现功能修复bug，而测试是为了找到bug
4、中间语言（msl）有什么作用？保证其他语言能够在.net（平台或框架）上运行

2020年11月4日的面试题目：
1、为什么string是不变的？一个string定义的字符串，一旦设定，就不能更改 string的比较运算：如果是引用类型，比较的是两个对象的堆地址，如果是值类型：比较的是两个对象的值
2、字符串池：在编译的时候，编译器会设置一个字符串池，可以节省很多堆空间，如果池中有相同的字符串，把这个相同字符串的堆地址赋值给新的变量 缺点：因为string可能非常大，会占用栈资源。
3、说一说stringBUilder:在实例化的时候，会默认的带有一个长度char[]的数组，如果长度不够的话，就会扩容，多余的空间用stringBUilderq去除，，调用tostring的时候，将char数组转为字符串。
4、tdd测试驱动开发有什么优缺点？

2020年11月5日的面试题目：只有私有的才小写。public大写。类名要大写。
1、泛型有什么特点？ 能够让代码组织重用：就是栈里面可以装各种类型的数据。可以多次使用。类型安全：编译时检查，让问题更早的暴露 ，提高性能：没有拆箱和装箱。
2、泛型有什么语法点？
3、？？和？.的两种语法有什么特点？
4、nullable,可空类型有什么特点？底层的实现是什么？

2020年11月8日的面试题目：
1、for循环和foreach循环有什么区别？ for循环可以用于数组和list集合，foreach循环可以用于集合,for循环的迭代基础是记数器和依靠下标（i++）在集合里还是通过下标来拿里面的元素
,foreach循环的基础是迭代器MoveNext(),foreach里面的item不能被赋值。直接就拿到了集合里面的元素。如果是键值对的形式，可以用foreach循环来拿值。只有集合才能foreach
2、Git背后的原理是什么？head指针来指向分支，checkout来更新工作区的记录，把分支上所提交的内容复制到主分支上，这叫merge，是单向的
不是同步的,release到master,只会将release上新提交的内容复制到master上,不会将master的内容复制到release。分支已经被merge之后 ,才会显示出来。显示的是合并之后提交的信息，不是没有合并
之前的信息，要在提交的分支上去找，当两个分支相同的位置都出现了不同的更改，git就无法自动merge，会报出conflict，要求我们resolve
和其他版本控制工具不同，无论是再仓库还是工作区，git都没有真正的为每个分支创建“副本”，git使用HEAD来确定当前活跃（正在被使用）的分支 
工作区总是“对标/比较/一致”HEAD指向的提交 ，实际上是创建一个新的“指针”，指针指向（当前分支中的）最后一次提交 ，不会让HEAD改变指向，改变HEAD的指向需要checkout。
每一次，实际上就是 ？checkout实际上是将HEAD指向新的分支 checkout会更新工作区文件,一次提交,本质上是一条内容更改的记录，但该条记录同时记录着它的上一次。让当前分支指向此次（最近的）提交 
远程分支存储在本地 ，除非fetch，本地保存的远程分支不会改变 ，以前的远程操作使用的是默认的远程分支 ，git push时可以指定远程的分支： ，如果不指定，默认同本地分支名 
如果远程上没有这个分支，自动创建一个 ，push到远程仓库的分支不能正在被checkout ，如果 git fetch 不指定分支，将获取所有分支信息/数据 ，git merge可以将远程分支合并到本地分支（不需要同名）
服务器上只有一个公用repository，向所有developer开放读/写权限 ，所有developers都向自己本地repository commit， 然后直接往公用repository上push ，这里要注意：先pull再pus
服务器上有一个权威（官方）repository，repository向所有人开放读权限，禁止写权限 ，所有developer在服务器上有自己的fork（如果得到认可，fork其实也可以成为权威……） 
可以向自己的fork push,但无法向权威repository 直接push,向别人的repository/fork提交内容,只能发出一股pull request,请求他人pull,然后由他人push,collaborators：方便。但是不便于代码质量控制
3、如果提交冲突了，想要保留两个提交记录，怎么办？
4、怎么避免提交冲突?
5、GitHub的fork有什么用? 和collaborators又是怎么一回事？

2020年11月9日的面试题目：
1、什么是委托？ 具体有什么作用？ 委托是一种特殊的类型,代表的是方法的引用,使用委托可以将方法引用封装在委托类型里面，然后可以将委托类型传递给可调用所引用的方法，委托是面向对象
2、什么是扩展方法，有什么作用？在不修改类的内部代码情况下，给这个类添加一个实例的方法。就是他没有一个方法，可以通过扩展方法来使用
3、集合的继承结构是怎么样的？Ilist,Idictionary:Icollection : IEnumerable<out T> :IEnumerable,为什么需要定义这么多接口？ 因为:方便归纳和记忆，基类/接口当做参数使用,有更广泛使用方法
4、委托类型的变量和普通类型的变量有啥区别？相同点：可以被赋值，作为方法参数传递和返回值， 不同点： 委托类型变量装的方法，调用时直接使用，普通方法装的是数据 ，需要先赋值在使用
5、如果当方法的参数定义过多，是由于没有封装好。
6、委托的本质上是方法，委托是一种特殊的泛型类型，
7、集合的继承结构有什么作用？没有继承结构，集合类之间的关系会显得很乱，所以有了继承结构可以很清楚的直到集合是继承了那个集合的，方便记忆，整理归纳，只要实现了Ienumerable,

2020年11月11日的面试题目：
1、any有什么作用？ 在这个集合的元素里面，有没有满足这个条件的元素
2、匿名方法有什么特点？ 没有方法名，由关键字delegate代替，匿名方法不需要标志返回值类型，参数不能标记为ref/out/in的引用传递参数除外 
3、lambda有什么语法特点？将匿名方法的delegete去掉，使用箭头=>代替，可以不指定参数类型，一行方法体实现，可以不用{}，一个参数，可以不用（）；没有参数，还是要有一个空括号，而且不能写return 
4、闭包有什么特点？闭包中使用匿名方法，于是就产生了外部方法不能使用匿名方法中的变量，匿名方法中能使用外部的变量和参数
5、什么是事件，和委托有什么关系？委托是事件的基础，事件又对委托进行了封装，事件就是： 先定义一个事件，用于发布，实例化一个发布事件，当事件被btn_click订阅，即：当这个btn被click时调用btn_click()方法
就是调用了里面定义的方法，事件被触发，给予一个处理结果。
6、委托、lambda表达式、匿名方法、事件之间有什么联系？ 委托是一种特殊的类型，委托类型变量可以装方法，由于为了减少声明方法（由于方法中只有一句语句，就出现了匿名方法，没有方法名，由关键字delegate
代替，没有返回值类型，为了简写代码，就有了lambda表达式，用=>代替，只有一个参数时，不用括号，返回的是方法的返回类型,委托是事件的基础，事件又对委托进行了封装

2020年11月12日：
1、什么是斜变、逆变，有什么作用？有什么特点？ 变体不能用于泛型类和泛型方法、值类型，主要是为了被定义的泛型接口和委托，应用的更广泛，可以重载 
斜变out  子类可以替父类 逆变 in 父类可以替子类，在声明的时候使用，只能用于泛型接口和委托，在类型参数前添加
2、什么是linq，有什么特点？有什么作用？ 在集合的增删改查中，最多的是查，以前我们只有用for和foreach来遍历查找，linq并非只针对集合 linq to Object，还可以linkq to db 
、linq to xml文件、linq to webservice / linq针对于集合的操作都属于 linq to object ,以from 开头  有var ，以select结尾 、 还有where、，只要实现了Ienumarable的子类都可以进行集合的查找
返回的结果类型为：Ienumerable类型，其中泛型还可以嵌套，比如：linq用了分组之后，它返回类型是Ienumerable<Igrouping<T,T>>,分组是还可以有其他方法，cout average 接口不能实例化，所以这些都是
它的扩展方法。
3、select和where的区别在哪里？where是横向的操作，select是纵向的操作，纵向取出来的可能数个属性，横向这一行取出来的是什么就是什么，不会有多于其他的属性等
4、投影常用于group和join之后，从原有结果集中取出或增加若干属性重新组合成新的集合，还可以使用匿名对象，会使用关键字into  new
5、延迟执行有什么作用？  linq的查询表达式只是一个表达式，不存储查询结果 ，直到被foreach才会输出结果 ,在进行多条件查询时可以提高性能，
因为不是一次查询就输出结果，是当foreach循环使用的时候，才输出结果，提高了性能，获得及时数据。

2020年11月16日的面试题目：
1、异常与错误有什么区别？异常不是自动生成的,是被抛出来的,异常是运行时生成的,错误可以分为三种：编译时错误、运行时错误、逻辑错误。
2、linq方法的本质是什么？ C#编译器会将所有的linq表达式编译成一个方法,然后执行。linq to object的本质还是foreach,foreach的核心也是依靠movenext（）方法。

2020年11月17日的面试题目：
1、什么是异常，与错误有什么区别？异常不是自动生成的,是被抛出来的,异常是运行时生成的,错误可以分为三种：编译时错误、运行时错误、逻辑错误 异常可以理解为：程序运行时，发生了无法处理的情况或者
无法预料到的情况，是在正常情况下不会出现，出现了也“我”也无法处理和遇到的问题，并且程序应该中断执行
2、开发中，你是怎么看待抛异常的？遇到过什么困难没有? 会在代码里面写抛出异常，这个问题交给调用这段代码的用户或方法来解决，如果解决不了，就组成网上报，走到main函数，可以做一个统一处理
经常会碰到空引用异常，
3、线程、进程、同步、异步、并行、串行分别解释一下，有什么关联没有？进程：操作系统分配一定的资源给应用程序，进程之间的资源不能共享，线程：是进程的一个子单位，多个线程可以共享进程的资源
同步：一个任务接着一个任务的去执行 异步：多个任务同时执行，并行：多个任务同时进行，因为一个CPU核心同一个时间点只能处理一个任务，所以并行只能在多（核）处理器上实现，并行是能够真正提高程序运行效率的。
串行：一个任务接着一个任务的去执行 并发：多个任务去执行
异步：
4、在写代码的时候，你是怎么写抛出异常的？先写异常的具体子类，然后在最后的时候写个基类异常，如果有其他要求的话，可以写个finally，比如实现关闭数据库，在异常发生了之后，亦可以执行finally里面的代码
然后可以在异常后面加个变量名 ，再加上tostring就可以查到具体的哪一些抛出的异常
5、finally有什么特点？
6、使用异常应该注意哪些事项？不要把异常作为分支判断条件，不知道如何处理这个异常就不要处理，trycatch没有捕获的异常，把这些异常抛到main函数入口集中处理，异常会带来较大的性能消耗
异常会带来较大的资源开销（性能损耗），所以要尽可能避免异常被抛出（不是不写throw exception的代码） 不要使用exception做为分支判断条件 尽可能的使用具体的、.NET现有的异常
不知道怎么处理的，就不要处理 
不要catch之后，啥都不做（或者就包裹一下），直接throw 
总是在程序入口（顶层方法）处catch未捕获的异常

2020年11月18日的面试题目：
1、在实际开发中，你是怎么运用多线程的？ 首先线程是进程的子单元，多个线程可以共用进程的资源，当资源还很充足的时候，可以多开几个线程，已达到提高性能和提高用户的响应，当资源在沾满的情况下
再多开几个线程，是没有用处的。所以多开线程还是得看情况。多进程，还是多线程，本质上都是为了让多个进程/线程同时（或者至少看起来像同时）完成一个工作，
2、Task的代码层面和逻辑层面是怎么样的？说一说你对它的了解？ 代码层面：实现了一个接口IAsynResult的类，task<T>继承了task 逻辑层面来讲：task是一份工作任务，该工作任务会被异步的执行
在 未来的某个时间完成，task可以传一个委托，根据有无返回值来确定是action还是function，如果有个有参的方法传进来，可以用lambda表达式解决这个问题，wait和result会让运行停下来，等待task
完成，或者要取到task运行之后的返回值
3、单线程可不可以异步？ 可以 分情况：
4、前台和后台有什么区别？  主线程和new出来的线程都是前台线程    线程池里面的线程都是后台线程，如果前台线程终止，后台线程也会终止，反之不成立。
5、什么是线程池？理解“池（pool）”的概念： 一个线程使用完成后并不销毁，而是放回池中 ，所以池中可以存放多个线程 ，下次使用时直接从池中取出未使用的线程，一个进程只有一个线程池，池中的线程都是： 
后台线程，使用默认的priority ，使用相同的栈大小
5、新开一个Task并不总是新开一个Thread！ 
从逻辑上讲，Task是比线程“更高层的抽象”，它是对任务（work）的封装，而不是线程（thread）的封装 
从实现上讲，异步并不一定需要一个线程。是否开启一个新线程，是由scheduler决定的，目前来说：
I/O相关异步，是不开新线程的，异步由底层I/O实现 
CPU相关的线程，会利用TaskSchedular从线程池获取 

2020年11月19日的面试题目：
1、什么是异步方法？有什么作用？声明的时候又async,有async不一定异步，同步也可以别标记为async，方法体里有await，没有await的话，会报警告，
异步是在await的时候开始的，先执行awaitable里面的内容，返回方法的调用处，然后执行其后的代码 async等待，await后面接的是awaitable,提高性能
从await开始，task开始异步，一边执行await后的表达式内容，一边返回到方法调用处继续执行，直到await的内容执行完成之后，才会返回async方法处，才继续执行await之后的剩余代码
调用wait的异步方法，wait会把当前线程阻塞进行等待，另外一个线程的执行完毕
2、async和await会不会新开一个线程？ 不会
3、tpl是什么？ 有什么作用？task parallel liabary 任务并行库，是一个类库，简化异步、并行，在底成实现上是：分区处理，动态调整并行规模，线程调度等。

2020年11月20日的面试题目：
1、什么是I/O？io就是字节流的输入和输出，在内存上的输入数据叫Io,流出叫out,在内存和外存上的数据输入输出过程也叫io 
什么是路径？ pATH是一个静态类，主要是针对文件路径的字符串的操作，不会涉及文件和文件夹本身
2、你是怎么了解流这个类的？流是一有序的命名的字节组合，文件的读写的本质就是字节流的输入和输出
3、文件和文件夹都有实例和静态的方法？你是怎么选择使用的？path 文件和文件夹都是一个静态的类，静态类里面所有的成员都是属于这个类的，
是共有的，为方便开发，违背了面向对象的特点，能实例就不要静态
4、对象与对象之间的关系可以有哪些？ 除了继承还可以是组合，他们之间的关系都是通过属性来建立的了解过ER模型吗？一对一 ，一对多。多对多，我们也把对象之间如何关联的关系称为er模型
5、stream里面的buffer听说过没有？ 并解释一下！buffer就是一个缓冲区，内存本身是很小的，磁盘装载的数据很大，很多，当调用磁盘里面的数据的时候，
是不能直接操作磁盘，只能通过内存来读取磁盘里面的内容，根据他们的特点，然后就可以在他们之间建立一个缓存区，以方便内存快速的读取数据，不用再一次从磁盘里面读取数据，
保证其运行和提高读取的速度
6、释放资源我应该正确的操作？首先这个类应该要继承Idispose，然后使用using块来释放资源，会发生异常的情况就用try，catch来包裹住，释放资源的dispose放在finally里面，无论有没有异常都应该这样做

2020年11月22日的面试题目：
2、什么是cs和bs? 客户端服务器  浏览器服务器，在服务器上有实现功能（代码）和在浏览器上有实现功能(代码)，cs也是一样的
1、什么是asp？ active serverpage 动态服务页面，与静态页面有什么区别？静态页面：就是自己写了一个html页面，声称一个HTML文件，把文件放在服务器上，然后点击就可以访问啦，在服务器上确实存在一个
页面就叫做HTML静态页面，在服务器端是动态生成的页面就叫做动态页面，动态页面是指页面的生成是动态合成的，一个页面与另外一个页面的内容是不同的,的HTML是合成的，内容是变化的，页面是在服务器端合成的
，有一些其他页面是在前端合成的，asp。net就是在服务器就生成了html文件，server端生成的是HTML页面
3、bsweb技术还有哪些？ PHP Java web asp.net webform 三大主流动态网站技术 .Net是一个平台，C#语言就运行在这个平台上的，以前的asp是以VBscript控制HTML页面
大力推广以.NET平台为基础的C#和VB.NET，ASP也由此变成了ASP.NET 语言可以分为两个系：C系（C++,C#,JAVA,C等）和B系（visual bysical 等）
4、.net和。framework有什么区别和联系？NET Framework：WebForm / MVC / SPA / API   NET core：MVC / RazorPage / API ..NET core 
MVC 
WebApi 
RazorPage  
5、我们学习的要点可以分为哪几部分？ 1、系统架构 2、代码组织 3、页面整理 4、http协议 5、数据流动










